using System;
using System.Xml;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

#if UNITY_EDITOR_WIN
using UnityEngine.Windows;
using System.Text;
#endif

namespace GameplayTagInternals
{

public class GameplayTagXMLParser : Singleton<GameplayTagXMLParser>
{
    private class GameplayTagTreeNode
    {
        public bool isRoot = false;
        public string fullName;
        public string relativeName;
        public GameplayTagTreeNode parent;
        public List<GameplayTagTreeNode> children;
        public GameplayTagTreeNode(GameplayTagTreeNode parent, string relativeName)
        {
            this.parent = parent;
            children = new List<GameplayTagTreeNode>();
            this.relativeName = relativeName;
            if(parent == null || parent.isRoot)
            {
                fullName = relativeName;
                return;
            }
            fullName = parent.fullName + "." + relativeName;
        }
    }

    protected override void Awake()
    {
        base.Awake();
        ParseXMLData();
    }

    const string XMLPath = "GameplayTags";
    bool loadedTable = false;
    private GameplayTagTreeNode treeRoot;

    public void ForceReimport()
    {
        loadedTable = false;
        ParseXMLData();
    }

    TextAsset GetFile()
    {
        if (loadedTable)
        {
            return null;
        }
        loadedTable = false;
        var file = Resources.Load<TextAsset>(XMLPath);
        if (file == null)
        {
            Debug.LogAssertion("ERROR: COULD NOT OPEN ABILITY XML");
        }
        return file;
    }
    
    void ParseXMLData()
    {
        TextAsset file = GetFile();
        if(file == null)
        {
            return;
        }
        XmlDocument doc = new XmlDocument();
        doc.LoadXml(file.text);

        XmlNodeList list = doc.SelectNodes("//comment()");
        foreach (XmlNode node in list)
        {
            node.ParentNode.RemoveChild(node);
        }
        treeRoot = new GameplayTagTreeNode(null, "NONE");
        treeRoot.isRoot = true;
        ParseNode(doc["root"], treeRoot);
        loadedTable = true;
    }

    void ParseNode(XmlElement node, GameplayTagTreeNode parent)
    {
        foreach (XmlElement tagDef in node.ChildNodes)
        {
            GameplayTagTreeNode child = new GameplayTagTreeNode(parent, tagDef.LocalName);
            parent.children.Add(child);
            ParseNode(tagDef, child);
        }
    }

#if UNITY_EDITOR_WIN
    const string TagEnumFilePath = "Assets/Scripts/GameplayTags/Generated_GameplayFlags.cs";
    public void GenerateTagEnumFile()
    {
        StringBuilder builder = new StringBuilder();
        builder.AppendLine("//this class is generated by GameplayTagXMLParser");
        builder.AppendLine("public static class GameplayTagFlags");
        builder.AppendLine("{");
        TraverseForGeneration(builder, treeRoot, 1);
        builder.Append("}");
        File.WriteAllBytes(TagEnumFilePath, Encoding.ASCII.GetBytes(builder.ToString().ToCharArray()));
        EditorUtility.RequestScriptReload();
    }

    void TraverseForGeneration(StringBuilder builder, GameplayTagTreeNode node, int tabCount)
    {
        builder.AppendLine(string.Format("{0}public static string {1} {{ get => \"{2}\"; }}", new string('\t', tabCount), node.relativeName.ToUpper(), node.fullName));
        foreach(var child in node.children)
        {
            TraverseForGeneration(builder, child, tabCount + 1);
        }
    }
#endif

    /// <summary>
    /// Helper method to check if we have already setup our table
    /// </summary>
    /// <returns>True if the table is loaded, false otherwise</returns>
    public bool XMLLoaded()
    {
        return loadedTable;
    }

    public List<string> GetRawTagList()
    {
        List<string> ret = new List<string>();
        TraverseTreeForTagList(treeRoot, ret);
        return ret;
    } 
    private void TraverseTreeForTagList(GameplayTagTreeNode node, List<string> ret)
    {
        ret.Add(node.fullName);
        foreach(var child in node.children)
        {
            TraverseTreeForTagList(child, ret);
        }
    }
}
}