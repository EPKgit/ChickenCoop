using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Text.RegularExpressions;
using System.IO;
using System.Text;

public class AbilityImporter : EditorWindow
{
    
    [MenuItem("Window/AbilityImporter")]
    public static void Init()
    {
        GetWindow(typeof(AbilityImporter));
    }

	public static bool IsAbilityScript(MonoScript script)
	{
		if (script == null)
		{
			return false;
		}
		const string pattern = @".*class.*:\s*Ability\s+";
		return Regex.IsMatch(script.text, pattern);
	}

    const string AbilityLoaderFilePath = "Assets/Scripts/Abilities/AbilityLookup.cs";

    void OnGUI()
    {
		if(GUILayout.Button("Reimport"))
		{
            Reimport();
        }
    }

    public static void Reimport()
    {
        AssetDatabase.Refresh();

        Dictionary<uint, Type> abilityLookup = new Dictionary<uint, Type>();

        DebugFlags.Log(DebugFlags.Flags.ASSET_WATCHDOG, $"Reimporting all Ability Data");
        List<string> allScriptGUIDS = new List<string>();
        allScriptGUIDS.AddRange(AssetDatabase.FindAssets("t:monoscript", new[] { "Assets/ScriptableObjects/Abilities" }));
        allScriptGUIDS.AddRange(AssetDatabase.FindAssets("t:monoscript", new[] { "Assets/PlayerAbilities" }));
        foreach (string GUID in allScriptGUIDS)
        {
            string path = AssetDatabase.GUIDToAssetPath(GUID);
            if (path == null)
            {
                continue;
            }

            DebugFlags.Log(DebugFlags.Flags.ASSET_WATCHDOG, $"Checking {path}");
            MonoImporter monoImporter = AssetImporter.GetAtPath(path) as MonoImporter;
            if (monoImporter == null)
            {
                continue;
            }

            MonoScript script = monoImporter.GetScript();
            Type scriptType = script.GetClass();
            if (scriptType.BaseType != typeof(Ability))
            {
                continue;
            }

            Ability a = Activator.CreateInstance(scriptType) as Ability;
            abilityLookup.Add(a.ID, scriptType);
        }

        if (abilityLookup.Count <= 0)
        {
            Debug.Log($"No abilities found");
            return;
        }

        StringBuilder builder = new StringBuilder();
        builder.AppendLine("//this file is generated by AbilityImporter");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("public static class AbilityLookup");
        builder.AppendLine("{");
        builder.AppendLine("\tpublic static Dictionary<uint, Type> Lookup = new Dictionary<uint, Type>()");
        builder.AppendLine("\t{");
        foreach (var pair in abilityLookup)
        {
            builder.AppendLine($"\t\t{{ {pair.Key}, typeof({pair.Value.Name}) }},");
        }
        builder.AppendLine("\t};");

        builder.AppendLine("\tpublic static Ability CreateAbilityFromId(uint ID)");
        builder.AppendLine("\t{");
        builder.AppendLine("\t\tif(!Lookup.ContainsKey(ID))");
        builder.AppendLine("\t\t{");
        builder.AppendLine("\t\t\treturn null;");
        builder.AppendLine("\t\t}");
        builder.AppendLine("\t\treturn Activator.CreateInstance(Lookup[ID]) as Ability;");
        builder.AppendLine("\t}");

        builder.AppendLine("}");

        DebugFlags.Log(DebugFlags.Flags.ASSET_WATCHDOG, $"Start file write");
        File.WriteAllBytes(AbilityLoaderFilePath, Encoding.ASCII.GetBytes(builder.ToString().ToCharArray()));
        DebugFlags.Log(DebugFlags.Flags.ASSET_WATCHDOG, $"End file write");
        EditorUtility.RequestScriptReload();
    }
}
